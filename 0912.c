#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>


#if 0
char* LED = (char*)0x3000;
main() {
	*LED = 1;  // *LED = 0;
}
#endif


// 0x07  0x09  0x12  0x34  0x56  0x78  0x1F  0x00
// 98    99    100   101   102   103   104   105
// char --> short --> int / long / float --> double / long long --> long double	
// 1바이트  2바이트   4바이트                8바이트                 8바이트 이상

// 낮은 번지 --> 낮은 숫자 , 높은 번지 --> 낮은 숫자            어떻게 읽을지는 컴퓨터마다 다를 수 있음
// Little-Endian             Big-Endian    ????? 이거 맞나

// 데이터의 표현과 의미
// 비트 / 바이트 / 워드 / 더블워드
// 10진수 / 2진수 / 16진수

// 비트
// 가장 작은 정보 단위
// 0 또는 1로 표현하는 2진수 값을 저장할 수 있는 메모리 공간
// n개의 비트는 2^n개의 정보를 저장
// 비트 연산자: 데이터의 각 비트 단위로 수행되는 연산자     논리연산자와 혼동 주의!
// &  |  ^  ~  <<  >>
// 값도 논리로 처리 가능  0 = False, 그 이외의 값 = True
// 0111 & 0010 --> 0010,  0010 & 0100 --> 0000    /    0111 && 0010 --> 1,  0010 && 0100 --> 1

// 바이트
// 비트가 연속적으로 8개 모인 정보단위
// 총 256가지의 정보 종류를 저장 가능
// 컴퓨터 별로 자료형의 메모리 크기가 다를 수 있음 --> sizeof 사용

// 2진수
// 0과 1 두 개의 숫자를 이용해 데이터를 표현하는 방식
// 자리수 많아지면 알아보기 힘들다

// 10진수
// 2진수 --> 10진수 : 쉬움

// 16진수
// 2진수 --> 16진수 : 4비트씩 끊어서 변환

// 0xFF = 155(10) = 1111 1111 (2)
// 0xFF & 0xF0 = 1111 1111 & 1111 0000 = 1111 0000 = 0xF0
// 0xFF >> 3 = 1111 1111 >> 3 = 0001 1111 = 0x1F
// 양수/음수일 때 shift 결과가 달라질 수 있음
// << 3, *8  의미는 같지만 << 3 의 속도가 훨씬 빠름


#if 0
char a = 2, b = 7;  // &a, &b : b의 주소는 a의 주소 바로 뒤 --> 주소가 1차이남
int main() {
	// a, b는 전역변수 / i,j는 지역변수  -->  a,b와 i,j의 주소는 분리됨
	int i, j;  // j의 주소가 i의 주소 앞, 주소가 12차이남
	// sizeof(long) = 4

	// a,b 변수와 i,j 변수의 주소 범위가 다르다, 주소의 순서도 다르다
	// 다시 실행하면 주소가 달라짐(그때마다 다르다)
	return 0;
}
#endif

#if 0
int main() {
	printf("%d\n", 1 ^ 2);
	printf("%d\n", 1 & 2);
	printf("%d\n", 1 | 2);
	printf("%d\n", 8 >> 2);
	printf("%d\n", 8 << 2);
	printf("%d %d %d %d %d %d %d\n", ~8, ~10, ~98, ~1000, ~909, ~10000000, ~0);
	printf("%d\n", 8 ^ ~2);
	printf("%d\n", 8 & ~2);
	printf("%d\n", 8 | ~2);

	int arr1[4], arr2[4], _and[4], _or[4], _xor[4];
	for (int i=0;i<4;i++){
		scanf("%1d", &arr1[i]);
	}
	for (int i = 0; i < 4; i++) {
		scanf("%1d", &arr2[i]);
	}
	for (int i = 0; i < 4; i++) {
		_and[i] = arr1[i] & arr2[i];
		_or[i] = arr1[i] | arr2[i];
		_xor[i] = arr1[i] ^ arr2[i];
	}
	for (int i = 0; i < 4; i++) {
		printf("%d", _and[i]);
	}
	printf("\n");
	for (int i = 0; i < 4; i++) {
		printf("%d", _or[i]);
	}
	printf("\n");
	for (int i = 0; i < 4; i++) {
		printf("%d", _xor[i]);
	}
	printf("\n");

	return 0;
}
#endif
