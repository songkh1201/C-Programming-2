#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

// 1차원 배열과 문자열, 다차원 배열, 포인터

// 포인터
// 담는 것이 무엇이고 가리키는 것이 무엇인지,
// 주어진 것인지 바꿀 수 있는 것인지,
// 상수인지, 변수인지
// 변수의 범위는 어디까지인지
// 그 크기는 어디까지인지
// 반드시 구별

// 배열(Arrays)
// 
// 자료형 array
// C언어에서의 derived data types 중 하나
//		Derived data type
//		Fundamental data type(int, char, float, ...)을 이용해서 만들어지는 자료형
// 
// Array는 index가 붙어 있는 자료형
// int a[10];
//	a[0], a[1],...,a[9]
//	배열의 첨자는 0부터 시작
// 
// 변수의 종류에 관계없이 낮은번지에서 높은 번지로 문자가 저장된다
// 배열은 반드시 시작점부터 데이터크기만큼 증가하여, 순서대로 만들어진다
// 지역변수, 전역변수 상관 X
// ex) char x;
// x[0] 상대 0번지
// x[1] 상대 1번지
// x[2] 상대 2번지
// 
// 배열의 종류
// - 모든 데이터 형을 배열로 만들 수 있다
// - 포인터도 배열의 데이터가 될 수 있다
// - 일정한 형태의 데이터가 같은 크기로 계속 반복되어 "연속"으로 저장된다
// 하나의 위치만 알면 모두 알 수 있다
// 
// - 그 중 char 문자는 "문장"이라는 특별함 때문에 "문자열"이라고 한다
// 연속으로 출력되는 등의 처리를 할 수 있기 때문에 다른 배열과 달리 주의를 기울여야 한다
// 
// 문자'' 문자가 갖고 있는 아스키 값으로 변환 가능
// 문자열"" 하나의 값으로 표현 불가, 어딘가에 저장해두고 필요할 때 불러서 위치를 알려줌
// 
// 배열의 초기화 기본
// int a[] = {1, 2}; == int a[2] = {1,2}
// 
// 문자열(String)
// - "I am a boy.", "String", ""(Null string), ...
// - NULL string은 비어 있는 문자열이라고 생각하면 된다
// - 문자열에 NULL (값 0) 만 있다는 뜻이다
// - NULL은 문자열의 끝을 나타내며, 문자열은 반드시 NULL로 끝나야만 한다
// (문자열은 printf() 등의 함수에서 연속으로 출력될 수도 있으므로 끝은 지정하지 않으면 끝낼 수가 없게된다.)
// - 문자열은 문자(character)의 집합
// 
// 문자열은 메모리에 어떻게 저장되는가?
// - "I am a boy."
// 1000  'I'
// 1001  ' '
// 1002  'a'
// 1003  'm'
// 1004  ' '
// 1005  'a'
// 1006  ' '
// 1007  'b'
// 1008  'o'
// 1009  'y'
// 1010  '.'
// 1011  '\0'
// 
// - 'I', ' ', 'a' 등은 문자(char)이다
// - '\0'은 문자열의 끝을 나타내는 특수문자이다. NULL
// - 변수의 종류에 관계없이 낮은 번지에서 높은 번지로 문자가 저장된다
// 
// char str[12];
// str[11] = '\0'; == str[11] = 0;

#if 0
int main() {
	int a = 3, b = 4;
	printf("%d %d\n", a, b);
	// 각각의 변수는 연속된 메모리에 저장된다는 보장이 전혀 없다
	// 실행되는 순간 운영체제의 상황 (혹은 시스템 상황)에 따라 위치는 달라진다
	// 배열은 반드시 연속적으로 저장된다
	return 0;
}
#endif

// 1차원 배열에서의 주소와 그 표현
// 1차원 char 배열의 주소와 표현
// 1차원 int 배열의 주소와 표현

// 1차원 char 배열의 주소와 표현
// char a[12] = "I am a boy.";  // 혹은 = {'I',' ','a','m',...} 처럼 써도됨
// a는 1000이다. (주소,상수)  // 나중에 임베디드보드를 쓸 때는 내가 원하는 번지에 원하는 값을 넣고 변수처럼 사용가능
// a는 포인터"상수" 이다. (변경불가,할당받음)  a는 char가 아니다
// a[0]은 'I'이다.(char 변수)
// a[0]부터 a[11]까지 각 char는 변수이다.
// &a[0]은 a[0] 문자의 주소인 상수이다.
// &a[0]은 a와 같다.
// - 배열의 이름(여기서는 a)은 "첫번째 덩어리"의 주소를 나타낸다.
#if 0
int main() {
	char addr, a[12] = "I am a boy.";

	printf("%p\n", a);
	printf("%p\n", &a[0]);
	printf("%c\n", a[0]);
	printf("%d\n", &a[2] - &a[0]);
	// printf("%d\n", &a[2] + &a[0]);
	
	// a와 &a[0]의 값이 같음을 알 수 있다.
	// a[0]는 char 값을 나타냄('I')
	// 주소의 차이는 계산해서 구할 수 있으나,(그 결과 2에 대해서는 뒤에서 다시 체크해보자.앞시간 참조)
	// 주소끼리의 합은 연산할 수 없다.
	// 그래서 &a[2] + &a[0]은 구할 수 없다. 허용되지 않는다. 더하면 너무 큰 수가 나올 수도 있어서(6+6 = 12)
	return 0;
}
#endif

// 문자열을 제외하고는 이런 식으로 배열 값을 할당 하는 경우는 없다. 문자열이 특별한 경우
// 프로그램에서 ""로 표현되는 문자열이 있으면 텍스트 영역(코드와 같은 정해진 상수값들을 저장하는 영역)에 일단 문자열을 저장하고,
// char 배열인 변수공간에 그 문자열을 다시 복사 해 놓는다.
// 그리고, 그 문자열의 첫번째 위치를 a로 나타낸다.
// 컴파일러는 모든 변수 이름을 상대 주소로 바꾸어 처리한다. 변수명은 없어진다. 따라서 이 과정에서 char,int 등 모든 크기에 맞는 주소계산이 이루어진다.
// 실제 컴퓨터는 a라는 것은 모르고 실제 할당된 주소로 계산 & 처리한다. (컴퓨터에는 a,b 등 변수가 없다)

// char a[12] = "I am a boy."; 에서
// a[0] ~ a[11] 까지 모든 char 값은 변수이다
// 즉, 문자값을 모두 변경할 수 있다.
// a 및, &a[0] ~ &a[11] 의 모든 주소는 상수이다.
// 즉, 주소값은 할당받는 것이지, 임의로 변경할 수는 없다.

// 1차원 int 배열의 주소와 표현
// char i[12] = {100,200,300,400,500}
// 1000  100
// 1004  200
// 1008  300
// 1012  400
// 1016  500
// 1020  0
// 1024  0
// 1028  0
// 1032  0
// 1036  0
// 1040  0
// 1044  0
// 나머지는 char 배열과 동일
#if 0
int main() {
	int diff, i[12] = { 100,200,300,400,500 };
	printf("%p\n", i);
	printf("%p\n", &i[0]);
	printf("%d\n", i[0]);

	diff = &i[2] - &i[0];
	printf("%d\n", &i[2] - &i[0]);  // 2  그 사이에 integer가 몇개 있는가(8이 아님)
	// 주소값의 +- 연산은 그 "다음","이전"의 의미이다.
	// 따라서 두 주소의 - 연산은 그 사이에 char 또는 int가 각각 몇 개 들어가는 공간인지를 구하는 것
	// i[2]의 주소와 i[0]의 주소의 실제 메모리 차이, 즉 8을 구하기 위해서는
	// 각각을 주소가 아닌 숫자로 생각하고 연산해야함
	// (int)&i[2] - (int)&i[0]
	return 0;
}
#endif


// 다차원 배열
// - 2차원 이상의 배열을 의미함
// - 다차원 배열의 선언
//	int arr[100]  1차원 배열
//	int arr[10][10]  10x10, 2차원 배열
//	int arr[5][5][5]  5x5x5, 3차원 배열
// - 몇 개씩의 데이터가 묶여있는지 확인(덩어리)
// - arr이 나타내는 것은 가장 큰 첫번째 덩어리

// 2차원 배열의 메모리 구조
// int arr[3][4];
// [0][0] | [0][1] | [0][2] | [0][3] | [1][0] | [1][1] | [1][2] | [1][3] | [2][0] | [2][1] | [2][2] | [2][3]
// 
// 다차원 배열의 실제 메모리 구성
// - 1차원 배열과 동일하다
// 다만 접근 방법을 2차원적으로 해석할 뿐
// - 2차원 적으로 이해하는 것이 편하다
// - 그러나 물리적 위치를 정확하게 이해하기 위해 그림을 머릿속에서 이해할 수 있어야함
 
// 2차원 배열 선언과 동시에 초기화
// - case 1: 행 단위로 모든 요소들을 초기화
// - case 2: 행 단위로 일부 요소들만 초기화
// int somag[3][3] ={
//	{1,2,3}.	1 2 3
//	{4,5,6},	4 5 6
//	{7,8,9},	7 8 9
// };
// int somag[3][3] ={
//	{1}.		1 0 0
//	{4,5},		4 5 0
//	{7,8,9},	7 8 9
// };
// int somang[3][3] = {1,2,3, 4,5,6, 7}; 가능한 방법이지만 좋지 않은 방법 / 코드는 보기에 좋아야함
// 
// 초기화 리스트에 의한 배열 크기의 결정
// - 1차원 배열의 예
//	int arr[] = {1,2,3,4,5};  // OK
// - 2차원 배열의 예
//	int arr[][] = {1,2,3,4,5,6,7,8};  // Error
//	int arr[][4] = {1,2,3,4,5,6,7,8};  // OK
//	int arr[][2] = {1,2,3,4,5,6,7,8};  // OK

// 3차원 이상의 배열
// 3차원 배열의 선언과 의미
// - 3차원적 메모리 구조를 의미함
// - 일반적으로 자주 쓰지는 않는다. 분야/목적에 따라 다름.
// - 4차원 이상의 배열은 4차원의 형태가 되므로 구조적인 표현이 어렵다. 3차원 배열이 여러개...
// - 그러나 물리적 배치와, 각 주소의 표현방법은 정확하게 알고 있어야 함.(뒤에 이어 나올 3차원 기본내용을 참조)

// 2차원 배열의 주소와 표현
// int i[3][4] = {100,200,300,400,500,} -> 3덩어리 (다시 각 4덩어리)
// i는 1000이다. (주소,상수)
// 첫번째 덩어리의 주소를 나타낸다.(3개중 첫째)
// i는 포인터 상수 이다. (변경불가,할당받음)
// 여기서 모든 주소는 모두 상수이다.
// i[0]은 첫번째 덩어리중 다시 첫째 덩어리 주소
// 즉, 첫번째 int의 주소를 나타낸다
// 배열에서 값자체가 주소인데 다시 &를 붙인것은 바깥쪽 덩어리를 나타낸다
// 예를들어, i[0]는 [0][0]값의 주소이며, &i[0]는 [0]의 주소, 즉 i와 같다
// 3차원 이상의 배열에서는 매우 계산하기 힘드므로, 잘 이해하자
// 나중에 포인터 변수랑 연결되어 계산되니 주소 자체의 의미를 확실하게 알아야 한다.
#if 0
int main() {
	int diff, i[3][4] = { 100,200,300,400,500 };
	printf("i = %p\n", i);					// 0
	printf("i+1 = %p\n", i + 1);			// 16

	printf("&i = %p\n", &i);				// 0
	printf("&i+1 = %p\n\n", &i + 1);		// 48

	printf("i[0] = %p\n", i[0]);			// 0
	printf("i[1] = %p\n", i[1]);			// 16
	printf("i[2] = %p\n\n", i[2]);			// 32

	printf("i[0]+1 = %p\n", i[0] + 1);		// 4
	printf("i[1]+1 = %p\n", i[1] + 1);		// 20
	printf("i[2]+1 = %p\n\n", i[2] + 1);	// 36

	printf("&i[0] = %p\n", &i[0]);			// 0
	printf("&i[1] = %p\n", &i[1]);			// 16
	printf("&i[2] = %p\n\n", &i[2]);		// 32

	printf("&i[0]+1 = %p\n", &i[0] + 1);	// 16
	printf("&i[1]+1 = %p\n", &i[1] + 1);	// 32
	printf("&i[2]+1 = %p\n\n", &i[2] + 1);	// 48

	printf("&i[0][0] = %p\n", &i[0][0]);	// 0
	printf("&i[1][0] = %p\n\n", &i[1][0]);	// 16

	printf("&i[0][0]+1 = %p\n", &i[0][0] + 1);  // 4
	printf("&i[1][0]+1 = %p\n\n", &i[1][0] + 1);// 20

	printf(" %d\n", i[0][0]);  // 100

	return 0;
}
#endif

// 2차원 배열에서 모든 주소는 상수이다. (3차원 배열도 동일)
// int i[][] 의 정의에서는, [][] 형태인 것만 int 값이고, 나머지는 주소라고 생각하면 된다.
// 즉, i, i[0], i[1] 등은 모두 주소이다.
// 모든 주소의 의미(크기)를 알아야, +1의 값을 계산할 수 있다.
